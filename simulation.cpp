#include <iostream>
using namespace std;
#include <iomanip>
#include <string>
#include <vector>
#include <ctime>  // time for cooldown
#include <chrono> 
#include <fstream>
#include <algorithm> 



//Forward declaration Base Classes
class Utilities;
class Player;
class Environment;
class City;
class Vehicle;
class Building;


//Constant variables
const chrono::seconds WORK_COOLDOWN(30); // Cooldown for GoToWork action (30 seconds)
const double BASE_WORK_INCOME = 10000; // Base income from working (Increased for balance)
const double WORK_POLLUTION_IMPACT = 1.5; // Pollution generated by working (Slightly reduced)
const double BASE_ECO_SCORE_IMPROVEMENT = 0.5; // Base eco score improvement for green actions
const double PLANT_TREE_COST = 500; // Cost to plant a tree
const double PLANT_TREE_ECO_BENEFIT = 0.75; // Eco score benefit per tree planting action


//Forward declaration of functions
void checkGoalsAndGrantRewards();

// Function to handle pausing until user presses Enter
void pause() {
    cout << "\nPress Enter to continue...";
    cin.get(); // Wait for any single character
}


// Function to display currency (converts double to string)
string displayCurrency(double amount) {
    stringstream ss;
    ss << fixed << setprecision(2) << amount;
    return "$" + ss.str();
}


string educationalTips[] = {
    "Tip: Switching to renewable energy sources like solar panels drastically reduces pollution!",
    "Fact: Recycling one aluminum can saves enough energy to run a TV for three hours.",
    "Tip: Investing in public transport like railways reduces traffic congestion and emissions.",
    "Fact: Deforestation contributes significantly to climate change. Consider planting trees or adding green spaces!",
    "Tip: Well-maintained transport systems are more efficient and eco-friendly.",
    "Fact: Working generates income but also adds a small amount of pollution to your city.",
    "Tip: Higher population requires more resources. Ensure your utilities can handle the demand!",
    "Tip: Choosing Electric Vehicles (EVs) over Internal Combustion Engine (ICE) vehicles helps improve your city's EcoScore.",
    "Tip: Planting trees directly improves air quality and boosts your EcoScore."
};

void displayRandomTip() {
    int length = sizeof(educationalTips)/sizeof(educationalTips[0]);
    if (length) {
        int index = rand() % length;
        cout << "\n--------------------- Eco Tip ---------------------" << endl;
        cout << educationalTips[index] << endl;
        cout << "---------------------------------------------------\n" << endl;
    }
}


// Utilities (include Water, Gas, Electricity)
class Utilities {
protected:
    double capacity, currentUsage;

public:
    Utilities(double cap = 0) : capacity(cap), currentUsage(0) {}
    virtual ~Utilities() {}

    double getCapacity() const { return capacity; }
    double getCurrentUsage() const { return currentUsage; }

    virtual bool setUsage(double usage) {

        try{
            if (usage > capacity)
                throw runtime_error("Usage exceeds capacity");
            if (usage < 0)
                throw runtime_error("Usage cannot be negative");
            
            currentUsage = usage; return true;
        }catch(const runtime_error& e){
            cerr << "Error: " << e.what() << endl;
            return false;
        }
    }
    
    virtual string getType() const = 0;
};

class Water : public Utilities {
public:
    Water(double cap = 1000) : Utilities(cap) {}
    string getType() const override { return "Water"; }
};
    
class Electricity : public Utilities {
public:
    Electricity(double cap = 5000) : Utilities(cap) {}
    string getType() const override { return "Electricity"; }
};
    
class Gas : public Utilities {
public:
    Gas(double cap = 500) : Utilities(cap) {}
    string getType() const override { return "Gas"; }
};



//Building (Base class for all structures)
class Building {
protected:
    double landCover, cost; string buildingType;
    
public:
    Building(string type = "Generic", double land = 0, double c = 1000) : buildingType(type), landCover(land), cost(c) {}
    virtual ~Building() {}

    double getLandCover() const { return landCover; }
    string getBuildingType() const { return buildingType; }
    double getCost() const { return cost; }

    virtual void operate() { cout << "Operating a generic building." << endl; }
    virtual void displayDetails() const {
        cout << "Type: " << buildingType << ", Land Cover: " << landCover << " sq units, Cost: " << displayCurrency(cost);
    }
};

// Derived class of Building
class Residential : public Building {
protected:
    int populationCapacity;
    Water waterSupply; Electricity electricitySupply; Gas gasSupply;
    
public:
    Residential(string type, double land, double c, int popCap, double waterCap = 100, double elecCap = 200, double gasCap = 50)
        : Building(type, land, c), populationCapacity(popCap), waterSupply(waterCap), electricitySupply(elecCap), gasSupply(gasCap) {}

    int getPopulationCapacity() const { return populationCapacity; }

    void simulateDailyConsumption() {
        waterSupply.setUsage(waterSupply.getCurrentUsage() + populationCapacity * 0.12);
        electricitySupply.setUsage(electricitySupply.getCurrentUsage() + populationCapacity * 0.55);
        gasSupply.setUsage(gasSupply.getCurrentUsage() + populationCapacity * 0.06);
    }
    void displayDetails() const override {
        Building::displayDetails();
        cout << ", Population Capacity: " << populationCapacity << endl;
        cout << "  Utilities: Water (Usage/Cap: " << waterSupply.getCurrentUsage() << "/" << waterSupply.getCapacity()
                << "), Electricity (Usage/Cap: " << electricitySupply.getCurrentUsage() << "/" << electricitySupply.getCapacity()
                << "), Gas (Usage/Cap: " << gasSupply.getCurrentUsage() << "/" << gasSupply.getCapacity() << ")";
    }
};

// Residential Objects
class House : public Residential {
    int noOfRooms;
public:

    House(int rooms = 4, double land = 50, double cost = 45000)
        : Residential("House", land, cost, rooms * 2, rooms * 20, rooms * 50, rooms * 10), noOfRooms(rooms) {}
    //all house parameters are function of # of rooms

    void operate() override {
        cout << "A cozy " << noOfRooms << "-room house is lived in." << endl;
        simulateDailyConsumption();
    }
    void displayDetails() const override {
        Residential::displayDetails();
        cout << ", Rooms: " << noOfRooms << endl;
    }
};
    
class SkylineResidence : public Residential {
    int noOfApartments;
public:

    SkylineResidence(int apartments = 50, double land = 200, double cost = 750000)
        : Residential("Skyline Residence", land, cost, apartments * 3, apartments * 30, apartments * 80, apartments * 15), noOfApartments(apartments) {}
    //all house parameters are function of # of apartments
    
    void operate() override {
        cout << "A skyline residence with " << noOfApartments << " apartments provides housing." << endl;
        simulateDailyConsumption();
    }
        void displayDetails() const override {
        Residential::displayDetails();
        cout << ", Apartments: " << noOfApartments << endl;
    }
};



// Commercial Objects
class Mall : public Building {
    int noOfOutlets;
public:

    Mall(int outlets = 20, double land = 500, double cost = 350000)
        : Building("Mall", land, cost), noOfOutlets(outlets) {}

    void operate() override {
        cout << "The mall with " << noOfOutlets << " outlets is open for business." << endl;
    }
    void displayDetails() const override {
        Building::displayDetails();
        cout << ", Outlets: " << noOfOutlets << endl;
    }

};
class PowerPlant : public Building {
    double energyGencapacity;
    double pollutionGenerated;
    string energyType;
public:

    PowerPlant(string eType = "Coal", double capacity = 10000, double land = 400, double cost = 80000)
        : Building("Power Plant", land, cost), energyGencapacity(capacity), energyType(eType) {
        if (energyType == "Coal") { pollutionGenerated = 60; cost = 80000; } 
        else if (energyType == "Gas") { pollutionGenerated = 25; cost = 100000; } 
        else if (energyType == "Solar") { pollutionGenerated = 0.5; cost = 200000; capacity = 8000; } 
        else if (energyType == "Wind") { pollutionGenerated = 0.8; cost = 250000; capacity = 7500; } 
        else if (energyType == "Nuclear") { pollutionGenerated = 3; cost = 400000; capacity = 20000; }
        else { pollutionGenerated = 10; cost = 700000; } // default
        this->cost = cost;
    }
        double getEnergyCapacity() const { return energyGencapacity; }
        double getPollutionGenerated() const { return pollutionGenerated; }
        string getEnergyType() const { return energyType; }
        bool isRenewable() const { return (energyType == "Solar" || energyType == "Wind"); }
        void operate() override {
            cout << "The " << energyType << " power plant is generating " << energyGencapacity << " units of energy." << endl;
        }
        void displayDetails() const override {
            Building::displayDetails();
            cout << ", Energy Type: " << energyType << ", Capacity: " << energyGencapacity << ", Pollution/Cycle: " << pollutionGenerated << endl;
        }
};




class Transport {
protected:
    double maintenanceCost, travelCost, cost, maintenanceState;;
    int level;
  
public:


    Transport(double mcost = 100, double tcost = 10, double mstate = 100.0, int lvl = 1, double buildCost = 2000)
        : maintenanceCost(mcost), travelCost(tcost), maintenanceState(mstate), level(lvl), cost(buildCost) {}
    
    virtual ~Transport() {}
    
  
    double getMaintenanceState () const {return maintenanceState;}
    double getCost() const { return cost; }
    int getLevel() const {return level;}
    double getMaintCost() const { return maintenanceCost; }

    virtual void useTransport() {
        maintenanceState -= 0.5 * (1 + (100.0 - maintenanceState)/100.0); //degradation accelerate when in poor condition
        if (maintenanceState < 0) maintenanceState = 0;
        cout << "Using generic transport. Maintenance: " << fixed << setprecision(1) << maintenanceState << "%" << endl;
    }

    virtual bool performMaintenance(double budget) {
        if (maintenanceState >= 100.0) {
            cout << "Maintenance not needed (already at 100%)." << endl;
            return false;
        }
        if (budget >= maintenanceCost) {
            maintenanceState += 25.0;
            if (maintenanceState > 100.0) maintenanceState = 100.0;
            cout << "Performed maintenance. New state: " << fixed << setprecision(1) << maintenanceState << "%" << endl;
            return true;
        } else {
            cout << "Insufficient budget for maintenance (Required: " << displayCurrency(maintenanceCost) << ", Available: " << displayCurrency(budget) << ")" << endl;
            return false;
        }
    }
    virtual void displayDetails() const {
         cout << "Level: " << level << ", Maint. Cost: " << displayCurrency(maintenanceCost) << ", Travel Cost: " << displayCurrency(travelCost)
              << ", Maint. State: " << fixed << setprecision(1) << maintenanceState << "%, Build Cost: " << displayCurrency(cost);
    }
};

class Road : public Transport {
public:
    
    
    Road(int lvl = 1) : Transport(75 * lvl, 5.0 / lvl, 100.0, lvl, 4000 * lvl) {}

    //override base class functions (good practice)
    void useTransport() override {
        maintenanceState -= 0.3 * (1 + (100.0 - maintenanceState)/100.0);
        if (maintenanceState < 0) maintenanceState = 0;
        cout << "Used road network. Maintenance: " << fixed << setprecision(1) << maintenanceState << "%" << endl;
    }
    void displayDetails() const override {
        cout << "Type: Road Network, ";
        Transport::displayDetails(); cout << endl;}


};

class Railways : public Transport {
public:


    Railways(int lvl = 1) : Transport(250 * lvl, 2.0 / lvl, 100.0, lvl, 40000 * lvl) {} 

    //override base class functions (good practice)
    void useTransport() override {
        maintenanceState -= 0.15 * (1 + (100.0 - maintenanceState)/100.0);
        if (maintenanceState < 0) maintenanceState = 0;
        cout << "Used railway network. Maintenance: " << fixed << setprecision(1) << maintenanceState << "%" << endl;
    }
     void displayDetails() const override {
        cout << "Type: Railway Network, ";
        Transport::displayDetails(); cout << endl;}

        
};


class Airport : public Transport {
public:
    
    
    Airport(int lvl = 1) : Transport(1200 * lvl, 45.0 / lvl, 100.0, lvl, 150000 * lvl) {}
    
    //override base class functions (good practice)
    void useTransport() override {
        maintenanceState -= 0.6 * (1 + (100.0 - maintenanceState)/100.0); 
        if (maintenanceState < 0) maintenanceState = 0;
        cout << "Used airport. Maintenance: " << fixed << setprecision(1) << maintenanceState << "%" << endl;
    }
    void displayDetails() const override {
        cout << "Type: Airport, ";
        Transport::displayDetails(); cout << endl;}

};


//Vehicles --> ICE, EV
class Vehicle {
protected:
    string type; double cost, environmentalImpact;

public:

    Vehicle(string t, double c, double impact) : type(t), cost(c), environmentalImpact(impact) {}
    virtual ~Vehicle() {}
    

    string getType() const { return type; }
    double getCost() const { return cost; }
    double getEnvironmentalImpact() const { return environmentalImpact; }

    virtual void move() = 0;
    virtual void displayDetails() const {
        cout << "Type: " << type << ", Cost: " << displayCurrency(cost) << ", Env. Impact Score Mod: " << environmentalImpact;
    }
};

class EV : public Vehicle {
public:
    
    EV() : Vehicle("Electric Vehicle", 35000, 2.5) {}
    void move() override { cout << "An EV drives quietly, using electricity." << endl; }
     void displayDetails() const override {
        Vehicle::displayDetails();
        cout << " (Improves EcoScore)" << endl;
    }
};

class ICE : public Vehicle {
public:
    
    ICE() : Vehicle("ICE Vehicle", 22000, -3.0) {} 
    void move() override { cout << "An ICE vehicle drives, using gasoline and emitting fumes." << endl; }
    void displayDetails() const override {
        Vehicle::displayDetails();
        cout << " (Decreases EcoScore)" << endl;
    }

};

class Player {
    string playerName;
    double gold, experience; int greenLevel;
    
    vector<Vehicle*> vehicles; //used vector to overcome array size issues
    chrono::time_point<chrono::steady_clock> lastWorkTime; 

public:
    Player(string name = "DefaultPlayer", double startGold = 1000000, double startExp = 0) 
        : playerName(name), gold(startGold), experience(startExp), greenLevel(1),
          lastWorkTime(chrono::steady_clock::now() - WORK_COOLDOWN * 2) {}

     ~Player() {
        for (auto v : vehicles) {
            delete v;
        }
        vehicles.clear();
    }

    string getName() const { return playerName; }
    double getGold() const { return gold; }
    double getExperience() const { return experience; }
    int getGreenLevel() const { return greenLevel; }

    const vector<Vehicle*>& getVehicles() const { return vehicles; } //returns vector of vehicles

    bool canWork() const {
        auto now = chrono::steady_clock::now();
        auto timeSinceLastWork = chrono::duration_cast<chrono::seconds>(now - lastWorkTime);
        return timeSinceLastWork >= WORK_COOLDOWN; //player can only work after cooldown (30 seconds)
    }

    chrono::seconds getRemainingWorkCooldown() const {
         if (canWork()) return chrono::seconds(0);
         auto now = chrono::steady_clock::now();
         auto timePassed = chrono::duration_cast<chrono::seconds>(now - lastWorkTime);
         return WORK_COOLDOWN - timePassed;
    }

    void recordWorkTime() {
        lastWorkTime = chrono::steady_clock::now();
    }

    bool spendGold(double amount) {
        
        try{
            if (amount < 0)
                throw runtime_error("Cannot spend negative gold");
            if (gold <= amount)
                throw runtime_error("Not enough gold");

            gold -= amount;
            cout << playerName << " spent " << displayCurrency(amount) << ". Remaining gold: " << displayCurrency(gold) << endl;
            return true;

        }catch(const runtime_error& e){
            cerr << "Error: " << e.what() << endl;
            return false;
        }
        
    }

    void earnGold(double amount) {
        
        try{
            if (amount<0)
                throw runtime_error("Cannot earn negative gold");
            
            gold+= amount;
            cout << playerName << " earned " << displayCurrency(amount) << ". Total gold: " << displayCurrency(gold) << endl;
        }catch(const runtime_error& e){
            cerr << "Error: " << e.what() << endl;
        }
    }

    void addVehicle(Vehicle* vehicle) {
        if (vehicle) {
            vehicles.push_back(vehicle);
        }
    }

    void gainExperience(double amount) {
         if (amount < 0) {
             cerr << "Error: Cannot gain negative experience." << endl;
             return;
        }
        experience += amount;
        cout << playerName << " gained " << fixed << setprecision(1) << amount << " XP. Total experience: " << experience << endl;
    }

    void checkGreenLevelUp(double ecoScore) {
        int oldLevel = greenLevel; int newLevel;
        
        
        if (ecoScore >= 90) newLevel = 5;
        else if (ecoScore >= 75) newLevel = 4;
        else if (ecoScore >= 60) newLevel = 3;
        else if (ecoScore >= 45) newLevel = 2;
        else newLevel = 1;


        if (newLevel > oldLevel) {
            greenLevel = newLevel;
            cout << "\n*** Congratulations, " << playerName << "! You reached Green Level " << greenLevel << "! ***" << endl;
            // Reward based on achieving the new level
            addReward("Reached Green Level " + to_string(greenLevel), greenLevel * 15000, greenLevel * 75); // Increased rewards
        } else if (newLevel < oldLevel) {
             greenLevel = newLevel; // Level gets down if ecoScore rating falls
              cout << "\n*** Warning, " << playerName << "! Your Green Level dropped to " << greenLevel << " due to environmental decline! ***" << endl;
        }
    }

    void addReward(string description, double goldAmount, double xpAmount) {
        cout << "\n*** Reward Earned: " << description << " ***" << endl;
        if (goldAmount > 0) earnGold(goldAmount);
        if (xpAmount > 0) gainExperience(xpAmount);
        cout << "****************************************" << endl;
    }

    void displayStatus() const {
        cout<<*this<<endl;
        cout << "Vehicles Owned: " << vehicles.size() << endl;
        if (!vehicles.empty()) {
            for(const auto* v : vehicles) {
                cout << "  - ";
                v->displayDetails(); // Display basic vehicle info
            }
        }
        cout << "---------------------\n" << endl;
    }
    // Overloaded operator for displaying player status
    friend ostream& operator<<(ostream& os, const Player& p) {
    os << "Name: " << p.playerName << ", Gold: " << displayCurrency(p.gold)
       << ", XP: " << p.experience << ", Green Level: " << p.greenLevel<< ", Vehicles Owned: "<<p.vehicles.size()<<endl;
    return os;}

    //Operator for sorting players based on experience
    bool operator<(const Player& other) const {
    return experience < other.experience; }

};


class Environment {
    double pollutionLevel, ecoScore, greenSpaceFactor;
    int population;
    double transportNetworkScore, totalPowerCapacity, totalRenewablePowerCapacity, totalPowerDemand;
     

public:
    Environment() : pollutionLevel(15.0), ecoScore(20), population(0), transportNetworkScore(0),
                    totalPowerCapacity(0), totalRenewablePowerCapacity(0), totalPowerDemand(0), greenSpaceFactor(1.0) {} // Initial pollution slightly higher

    void updatePopulation(const vector<Building*>& buildings) {
        population = 0;
        for (const auto* building : buildings) {
            if (const Residential* res = dynamic_cast<const Residential*>(building)) {
                population += res->getPopulationCapacity();
            }
            
        }
        //Power Demand as a function of population
        totalPowerDemand = population * 1.1; 
    }

    void updatePowerGrid(const vector<Building*>& buildings) {
        
        totalPowerCapacity = 0; totalRenewablePowerCapacity = 0;
        
        pollutionLevel = 5.0; // Base pollution level reset each cycle, then added to
        for (const auto* building : buildings) {
            //dynamic_cast checks for type and returns nullptr if not
            if (const PowerPlant* pp = dynamic_cast<const PowerPlant*>(building)) {
                totalPowerCapacity += pp->getEnergyCapacity();
                pollutionLevel += pp->getPollutionGenerated(); // Considers pollution from power plants
                if (pp->isRenewable()) {
                    totalRenewablePowerCapacity += pp->getEnergyCapacity();
                }
            }
           
        }
    }
    void modifyPollution(double change) {
        pollutionLevel += change;
        if (pollutionLevel < 0) pollutionLevel = 0;
    }

    void improveGreenSpace(double amount) {
        greenSpaceFactor += amount;
        if (greenSpaceFactor < 0.1) greenSpaceFactor = 0.1;
        recalculateEcoScore();
    }

    void recalculateEcoScore(const vector<Vehicle*>& playerVehicles = {}) { 

        double pollutionImpact = pollutionLevel * 1.5; 
        double baseScore = 70.0 - pollutionImpact;

        // Bonus for renewable energy percentage
        double renewablePercent = calculateRenewableEnergyPercentage();
        double renewableBonus = (renewablePercent / 10.0); //+10 points if 100% renewable

        // Penalty(ICE) or Bonus (EV) from vehicles
        double vehicleImpact = 0;
        for(const auto* v : playerVehicles) {
            vehicleImpact += v->getEnvironmentalImpact();
        }

        // Bonus from green spaces
        double greenSpaceBonus = (greenSpaceFactor - 1.0) * 15.0; 

         // Bonus for good transport network
         double transportBonus = transportNetworkScore / 50.0; 

        ecoScore = baseScore + renewableBonus + vehicleImpact + greenSpaceBonus + transportBonus;

        // ecoScore = max(0.0, min(100.0, ecoScore));
    }
    void updateTransportScore(const vector<Transport*>& transport) {
        transportNetworkScore = 0;
        for(const auto* t : transport) {
            double maintenanceFactor = t->getLevel() * (t->getMaintenanceState() / 100.0); 
            if (dynamic_cast<const Road*>(t)) transportNetworkScore += 5 * maintenanceFactor;
            else if (dynamic_cast<const Railways*>(t)) transportNetworkScore += 20 * maintenanceFactor;
            else if (dynamic_cast<const Airport*>(t)) transportNetworkScore += 40 * maintenanceFactor; 
        }
     }

    double calculateRenewableEnergyPercentage() const {
        if (totalPowerCapacity <= 0) return 0.0;
        return (totalRenewablePowerCapacity / totalPowerCapacity) * 100.0;
    }

    friend ostream& operator<<(ostream& os, const Environment& env) {
        os << "--- City Environment ---" << endl;
        os << "Population: " << env.population << endl;
        os << "Pollution Level: " << fixed << setprecision(1) << env.pollutionLevel << " (Lower is better)" << endl;
        os << "EcoScore: " << fixed << setprecision(1) << env.ecoScore << " / 100" << endl;
        os << "Green Space Factor: " << fixed << setprecision(2) << env.greenSpaceFactor << endl;
        os << "Transport Network Score: " << fixed << setprecision(1) << env.transportNetworkScore << endl;
        os << "Power Demand: " << fixed << setprecision(1) << env.totalPowerDemand
        << " | Capacity: " << env.totalPowerCapacity << endl;
        os << "Renewable Energy: " << fixed << setprecision(1) << env.calculateRenewableEnergyPercentage() << "%" << endl;
        os << "------------------------\n" << endl;
        return os;}


    double getEcoScore() const { return ecoScore; }
    double getPollutionLevel() const { return pollutionLevel; }

};


//City Log template
template <typename T>
class CityLog {
    ofstream logFile;
public:
    CityLog(const string& filename = "logs.txt"){
        try{
            if (filename.empty()){
                logFile.open("default.txt", ios::app);
                throw runtime_error("Empty log filename provided. Using 'default.txt'. ");
            }
            logFile.open(filename, ios::app);
            if (!logFile.is_open()){
                throw runtime_error("Could not open log file: " + filename);
            }
        }catch(const runtime_error& e){
            cerr << "Error: " << e.what() << endl;
        }
    }  
    ~CityLog() { if (logFile.is_open()) logFile.close(); }
    void addEntry(const T& entry) { if (logFile.is_open()) logFile << entry << endl; }
};



class City {
string cityName;
Player cityPlayer;
Environment cityEnvironment;

vector<Building*> buildings;
vector<Transport*> transportSystems;

CityLog<string> actionLog;
vector<string> achievedGoals;

bool hasAchievedGoal(const string& goalName) {
    return find(achievedGoals.begin(), achievedGoals.end(), goalName) != achievedGoals.end();
}

public:
City(string name, string playerName) :
    cityName(name),
    cityPlayer(playerName),
    actionLog(name + "_" + playerName + "_log.txt")
{
    if (name.empty() || playerName.empty()) {
        throw runtime_error("City and Player names cannot be empty for log file creation.");
    }
    actionLog.addEntry("City '" + name + "' created for player '" + playerName + "'.");
    updateCityState();
}

~City() {
    for (Building* b : buildings) delete b;
    for (Transport* t : transportSystems) delete t;
    // Deleting buildings and transport pointer
    //Player destructor will handle vehicle deletion
}

void updateCityState() {
    cityEnvironment.updatePopulation(buildings);

    cityEnvironment.updatePowerGrid(buildings); 

    cityEnvironment.updateTransportScore(transportSystems);

    cityEnvironment.recalculateEcoScore(cityPlayer.getVehicles());

    cityPlayer.checkGreenLevelUp(cityEnvironment.getEcoScore());

    checkGoalsAndGrantRewards();
}


void BuyBuilding(Building* newBuilding) {
    if (!newBuilding) return;
    double cost = newBuilding->getCost();
    
    try {
        if (cityPlayer.spendGold(cost)) {
            buildings.push_back(newBuilding);
            
            if(auto* pp = dynamic_cast<PowerPlant*>(newBuilding)) {
                    if (!(pp->isRenewable())) {
                        cityEnvironment.modifyPollution(pp->getPollutionGenerated() * 0.1); 
                    }
            }
            cout << "Successfully purchased " << newBuilding->getBuildingType() << "." << endl;
            cityPlayer.gainExperience(cost / 150.0); // xp based on cost
            actionLog.addEntry("Bought " + newBuilding->getBuildingType() + " for " + displayCurrency(cost));
            updateCityState(); 
            if (dynamic_cast<PowerPlant*>(newBuilding) && dynamic_cast<PowerPlant*>(newBuilding)->isRenewable()) {
                displayRandomTip();
            }
        } else {
                cout << "Purchase failed. Not enough gold." << endl;
                delete newBuilding;
        }
    } catch (const std::runtime_error& e) {
        cerr << "Purchase Error: " << e.what() << endl;
        delete newBuilding;
    }
}

    void BuyTransport(Transport* newTransport) {
        if (!newTransport) return;
        double cost = newTransport->getCost();
        
        try {
            if (cityPlayer.spendGold(cost)) {
                transportSystems.push_back(newTransport);
                cout << "Successfully purchased transport infrastructure." << endl;
                cityPlayer.gainExperience(cost / 200.0);
                actionLog.addEntry("Bought Transport for " + displayCurrency(cost));
                updateCityState();
            } else {
                cout << "Purchase failed. Not enough gold." << endl;
                delete newTransport;
            }
        } catch (const std::runtime_error& e) {
            cerr << "Purchase Error: " << e.what() << endl;
            delete newTransport;
        }
    }

    void BuyVehicle(Vehicle* newVehicle) {
    if (!newVehicle) return;
    double cost = newVehicle->getCost();
    
    try {
        if (cityPlayer.spendGold(cost)) {
            cityPlayer.addVehicle(newVehicle); // Add vehicle to player's inventory
            cout << "Successfully purchased a " << newVehicle->getType() << "." << endl;
            cityPlayer.gainExperience(cost / 250.0); // xp for vehicle purchase
            actionLog.addEntry("Bought " + newVehicle->getType() + " for " + displayCurrency(cost));
            updateCityState(); // Update EcoScore based on new vehicle fleet
            displayRandomTip();
        } else {
            cout << "Purchase failed. Not enough gold." << endl;
            delete newVehicle;
        }
    } catch (const std::runtime_error& e) {
        cerr << "Purchase Error: " << e.what() << endl;
        delete newVehicle;
    }
}

void PlantTree() {
    cout << "\n--- Plant a Tree ---" << endl;
    cout << "Planting a tree costs " << displayCurrency(PLANT_TREE_COST) << " and improves the environment." << endl;
    if (cityPlayer.spendGold(PLANT_TREE_COST)) {
        cout << "Tree planted successfully!" << endl;
        cityEnvironment.improveGreenSpace(PLANT_TREE_ECO_BENEFIT / 15.0); // Improve green space factor
        cityPlayer.gainExperience(15); // Small XP gain for green action
        actionLog.addEntry("Planted a tree for " + displayCurrency(PLANT_TREE_COST));
        updateCityState(); // Update EcoScore
    } else {
        cout << "Not enough gold to plant a tree." << endl;
    }
    pause();
}


void PerformMaintenance() {
    cout << "\n--- Maintenance Center ---" << endl;
    if (transportSystems.empty()) {
        cout << "No transport systems require maintenance." << endl;
        return;
    }
    cout << "Select transport system to maintain (0 to cancel):" << endl;
    for (size_t i = 0; i < transportSystems.size(); ++i) {
            cout << i + 1 << ". ";
            transportSystems[i]->displayDetails();
    }
    cout << "Enter choice: ";
    int choice; cin >> choice;

        if (cin.fail() || choice <= 0 || choice > transportSystems.size()) {
        cin.clear(); cin.ignore(numeric_limits<streamsize>::max(), '\n');
        cout << "Invalid choice or cancellation." << endl; return;
        }
        Transport* target = transportSystems[choice - 1];
        double maintCost = target->getMaintCost(); 

        
        if (target->performMaintenance(cityPlayer.getGold())) { 
        
        if(cityPlayer.spendGold(maintCost)) {
            cout << "Maintenance successful and paid for." << endl;
                actionLog.addEntry("Performed maintenance on transport #" + to_string(choice) + " for " + displayCurrency(maintCost));
                updateCityState(); 

        }
}}

void GoToMall() {
    cout << "\n--- Going to the Mall ---" << endl;
    bool mallExists = false;
    for(const auto* b : buildings) { if(dynamic_cast<const Mall*>(b)) { mallExists = true; break; } }
    if (!mallExists) { cout << "There's no mall in the city!" << endl; return; }
    double cost = 75.0; 
    if (cityPlayer.spendGold(cost)) {
        cout << "Spent " << displayCurrency(cost) << " at the mall. It was fun!" << endl;
        cityPlayer.gainExperience(12); 
        actionLog.addEntry("Visited the mall, spent " + displayCurrency(cost) + ", gained 12 XP.");
            updateCityState(); 
    } else {

        cout << "Not enough gold to go shopping at the mall." << endl;
    }
}

void GoToWork() {
    cout << "\n--- Go To Work ---" << endl;

    if (cityPlayer.canWork()) {

        double earnings = BASE_WORK_INCOME + (cityPlayer.getGreenLevel() * 250) + (cityPlayer.getExperience() * 0.05);

        cout << "Working hard at a community job..." << endl;
        cityPlayer.earnGold(earnings);
        cityEnvironment.modifyPollution(WORK_POLLUTION_IMPACT); 
        cityPlayer.gainExperience(25); 
        cityPlayer.recordWorkTime();
        actionLog.addEntry("Worked, earned " + displayCurrency(earnings) + ", gained 25 XP, added pollution.");
        updateCityState();
    } else {
        chrono::seconds remaining = cityPlayer.getRemainingWorkCooldown();
        cout << "You need to rest! Try again in " << remaining.count() << " seconds." << endl;
    }
}

friend ostream& operator<<(ostream& os, const City& city) {
os << "\n\n==================== CITY REPORT: " << city.cityName
    << " (" << city.cityPlayer.getName() << ") ====================" << endl;
os << city.cityPlayer << endl;
cout<<city.cityEnvironment<<endl;

os << "--- Buildings (" << city.buildings.size() << ") ---" << endl;
if (city.buildings.empty()) os << "No buildings yet." << endl;
else {
    for (size_t i = 0; i < city.buildings.size(); ++i) {
        os << i + 1 << ". ";
        city.buildings[i]->displayDetails();
        os << endl;
    }
}

os << "\n--- Transport Infrastructure (" << city.transportSystems.size() << ") ---" << endl;
if (city.transportSystems.empty()) os << "No transport systems yet." << endl;
else {
    for (size_t i = 0; i < city.transportSystems.size(); ++i) {
        os << i + 1 << ". ";
        city.transportSystems[i]->displayDetails();
    }
}

os << "========================================================================\n" << endl;
return os;}


void Compete(const City& opponentCity) const {
    cout << "\n--- City Competition: " << cityName << " vs " << opponentCity.cityName << " ---" << endl;
    cout << "\n" << cityName << " (" << cityPlayer.getName() <<") Stats:" << endl;
    cout<<cityEnvironment;
    cout << "\n" << opponentCity.cityName << " (" << opponentCity.cityPlayer.getName() << ") Stats:" << endl;
    cout<<opponentCity.cityEnvironment;
    cout << "\n--- Comparison ---" << endl;
    double myScore = cityEnvironment.getEcoScore();
    double opponentScore = opponentCity.cityEnvironment.getEcoScore();
    cout << cityName << " EcoScore: " << fixed << setprecision(1) << myScore << endl;
    cout << opponentCity.cityName << " EcoScore: " << fixed << setprecision(1) << opponentScore << endl;
    if (myScore > opponentScore) cout << cityName << " has a higher EcoScore!" << endl;
    else if (opponentScore > myScore) cout << opponentCity.cityName << " has a higher EcoScore!" << endl;
    else cout << "Both cities have the same EcoScore!" << endl;
        
    cout << "----------------------------------------------------\n" << endl;
}

void checkGoalsAndGrantRewards() {
    double currentEcoScore = cityEnvironment.getEcoScore();
    double currentRenewablePercent = cityEnvironment.calculateRenewableEnergyPercentage();
    double currentPollution = cityEnvironment.getPollutionLevel();

    string goalRenewable = "Renewable Energy Leader";
    if (!hasAchievedGoal(goalRenewable) && currentRenewablePercent >= 75.0) { 
        cityPlayer.addReward(goalRenewable + " (>=75% Renewable Power)", 75000, 600); 
        achievedGoals.push_back(goalRenewable);
    }
    string goalLowPollution = "Clean Air City";
        if (!hasAchievedGoal(goalLowPollution) && currentPollution <= 12.0) {
        cityPlayer.addReward(goalLowPollution + " (Pollution <= 12)", 30000, 400);
        achievedGoals.push_back(goalLowPollution);
        }
        string goalTopEco = "Peak EcoScore Achieved";
        if (!hasAchievedGoal(goalTopEco) && currentEcoScore >= 95.0) { 
        cityPlayer.addReward(goalTopEco + " (EcoScore >= 95)", 150000, 1200); 
        achievedGoals.push_back(goalTopEco);
        }
        string goalFirstEV = "First Electric Vehicle";
        if (!hasAchievedGoal(goalFirstEV)) {
            for(const auto* v : cityPlayer.getVehicles()) {
                if(dynamic_cast<const EV*>(v)) {
                        cityPlayer.addReward(goalFirstEV + " (Purchased an EV)", 5000, 50);
                        achievedGoals.push_back(goalFirstEV);
                        break;
                }
            }
        }
}


string getCityName() const { return cityName; }
string getPlayerName() const { return cityPlayer.getName(); }
double getEcoScore() const { return cityEnvironment.getEcoScore(); }
const Player& getPlayer() const { return cityPlayer; } 


void showBuildingMenu() {
    cout << "\n--- Build Structure Menu ---" << endl;
    
    House tempHouse; cout << "1. House (" << displayCurrency(tempHouse.getCost()) << ")" << endl;
    SkylineResidence tempSky; cout << "2. Skyline Residence (" << displayCurrency(tempSky.getCost()) << ")" << endl;
    Mall tempMall; cout << "3. Mall (" << displayCurrency(tempMall.getCost()) << ")" << endl;
    PowerPlant tempCoal("Coal"); cout << "4. Power Plant (Coal) (" << displayCurrency(tempCoal.getCost()) << ")" << endl;
    PowerPlant tempSolar("Solar"); cout << "5. Power Plant (Solar) (" << displayCurrency(tempSolar.getCost()) << ")" << endl;
    PowerPlant tempWind("Wind"); cout << "6. Power Plant (Wind) (" << displayCurrency(tempWind.getCost()) << ")" << endl;
    PowerPlant tempNuclear("Nuclear"); cout << "7. Power Plant (Nuclear) (" << displayCurrency(tempNuclear.getCost()) << ")" << endl;
    cout << "0. Cancel" << endl;
    cout << "Enter choice: "; int choice; cin >> choice;  cin.ignore(numeric_limits<streamsize>::max(), '\n');

    if (cin.fail()) { cin.clear(); cin.ignore(numeric_limits<streamsize>::max(), '\n'); cout << "Invalid input." << endl; return; }

    Building* building = nullptr;
    switch (choice) {

        // Uses constructor defaults
        case 1: building = new House(); break;
        case 2: building = new SkylineResidence(); break;
        case 3: building = new Mall(); break;
        case 4: building = new PowerPlant("Coal"); break;
        case 5: building = new PowerPlant("Solar"); break; 
        case 6: building = new PowerPlant("Wind"); break;  
        case 7: building = new PowerPlant("Nuclear"); break; 
        case 0: cout << "Build cancelled." << endl; return;
        default: cout << "Invalid choice." << endl; return;
    }
    if (building) BuyBuilding(building); 

}

void showTransportMenu() {
    cout << "\n--- Build Transport Menu ---" << endl;
    Road tempRoad; cout << "1. Road Network (" << displayCurrency(tempRoad.getCost()) << ")" << endl;
    Railways tempRail; cout << "2. Railway Network (" << displayCurrency(tempRail.getCost()) << ")" << endl;
    Airport tempAir; cout << "3. Airport (" << displayCurrency(tempAir.getCost()) << ")" << endl;


    cout << "0. Cancel" << endl;
    cout << "Enter choice: "; int choice; cin >> choice; cin.ignore(numeric_limits<streamsize>::max(), '\n');

        if (cin.fail()) { cin.clear(); cin.ignore(numeric_limits<streamsize>::max(), '\n'); cout << "Invalid input." << endl; return; }

    Transport* transport = nullptr;
    switch (choice) {
        case 1: transport = new Road(); break;
        case 2: transport = new Railways(); break;
        case 3: transport = new Airport(); break;
        case 0: cout << "Build cancelled." << endl; return;
        default: cout << "Invalid choice." << endl; return;
    }
        if (transport) {
        BuyTransport(transport);
        }
}


void showVehicleMenu() {
    cout << "\n--- Buy Vehicle Menu ---" << endl;
    EV tempEV; cout << "1. Electric Vehicle (EV) (" << displayCurrency(tempEV.getCost()) << ") - EcoScore +" << tempEV.getEnvironmentalImpact() << endl;
    ICE tempICE; cout << "2. ICE Vehicle (" << displayCurrency(tempICE.getCost()) << ") - EcoScore " << tempICE.getEnvironmentalImpact() << endl;
    cout << "0. Cancel" << endl;
    cout << "Enter choice: "; int choice; cin >> choice; cin.ignore(numeric_limits<streamsize>::max(), '\n');

    if (cin.fail()) { cin.clear(); cin.ignore(numeric_limits<streamsize>::max(), '\n'); cout << "Invalid input." << endl; return; }

    Vehicle* vehicle = nullptr;
    switch (choice) {
        case 1: vehicle = new EV(); break;
        case 2: vehicle = new ICE(); break;
        case 0: cout << "Purchase cancelled." << endl; return;
        default: cout << "Invalid choice." << endl; return;
    }
        if (vehicle) {
        BuyVehicle(vehicle);
        }
}

void DriveVehicle(){
    int ICE = 0, EV = 0;
    const vector<Vehicle*> myVehicles = (cityPlayer.getVehicles());
    if (!size(myVehicles)){cout<<"You currently don't own any vehicle.\n"; return;}

    for (int i = 0; i < size(myVehicles); i++) {
        cout << i+1 << ". ";
        if (myVehicles[i]->getType() == "Electric Vehicle") 
            cout << "Electric Vehicle #" << ++EV << "\n";
        else 
            cout << "ICE Vehicle #" << ++ICE << "\n";    
    }

    cout<<"0. Cancel\n";
    int option = -1;
    
    while (not(option>=0 && option <=size(myVehicles))){
        cout << "Which car do you want to drive?\n"; cin>>option; cin.ignore(numeric_limits<streamsize>::max(), '\n');
        if (!option) return;
    }

    myVehicles[--option]->move();
    if (myVehicles[option]->getType() == "Electric Vehicle"){
        cityPlayer.gainExperience(50); cityEnvironment.modifyPollution(2);
    }
    else{
        cityPlayer.gainExperience(15); cityEnvironment.modifyPollution(10);
    }
        
}

};




int main() {
    
  
  return 0;
}